<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>SwiftUI and CoreData: The MVVM Way</title>
    <meta name="description"
        content="">
    <link rel="canonical" href="https://mattrighetti.github.io/2021/02/03/swiftui-and-coredata-mvvm.html">
    <link rel="alternate" type="application/rss+xml" title="mattrighetti"
        href="https://mattrighetti.github.io/feed.xml">

    <link rel="stylesheet" href=" /css/font.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" href=" /css/style.css">
    <link rel="stylesheet" href=" /css/code.css">
</head>

<body class="mx-auto max-width">
    <header class="mx-auto site-header">
        <nav>
            <a class="-title" href="/">mattrighetti</a>
            
            
            
            
            
            
            
            <a href="/about.html">About</a>
            
            
            
            
            
            
            
            
            
            <a href="/projects.html">Projects</a>
            
            
            
            
            
            <a href="/resume.html">Resume</a>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </nav>
    </header>

    <main>
        <article>
  <h1>SwiftUI and CoreData: The MVVM Way</h1>
  <div class="post-meta sect1">Feb 3, 2021</div>
  <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>When I first started using SwiftUI for some small projects, I immediately
appreciated its ease of use and expressiveness. However, it was not all rosy.</p>
</div>
<div class="paragraph">
<p>As soon as I began to work on some bigger apps — especially the ones that
required Core Data — it became clear to me that I would have to give a different
structure to the project itself. Otherwise, I would soon get entangled in a very
serious maintainability and testing problem.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-bad-easy-way">The Bad, Easy Way</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By going through Apple’s documentation and many other
answers on Stack Overflow, what you will find is a lot of people placing the
FetchRequest property wrapper variable inside a View struct that needs to fetch
some data from the Core Data model.</p>
</div>
<div class="paragraph">
<p>This might be tempting if you’re just starting out, but as you dig a little
further into the logic involved with the fetched entities, you will soon realise
that not only is it very hard — if not impossible — to test those
functions/variables, but you are also no longer following the MVVM pattern. At
that point, the View struct knows a lot about the entities and the
functions/properties that you defined inside them. Let me show you an example
that is easily replicable with other entities:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">SimpleList</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@FetchRequest</span><span class="p">(</span>
        <span class="nv">entity</span><span class="p">:</span> <span class="kt">Course</span><span class="o">.</span><span class="nf">entity</span><span class="p">(),</span>
        <span class="nv">sortDescriptors</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">)</span> <span class="k">var</span> <span class="nv">courses</span><span class="p">:</span> <span class="kt">FetchedResults</span><span class="o">&lt;</span><span class="kt">Course</span><span class="o">&gt;</span>

    <span class="k">var</span> <span class="nv">overallGpa</span><span class="p">:</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">numCourses</span> <span class="o">=</span> <span class="n">courses</span><span class="o">.</span><span class="n">count</span>
        <span class="k">let</span> <span class="nv">gradeSum</span> <span class="o">=</span> <span class="n">courses</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">score</span> <span class="p">}</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gradeSum</span> <span class="o">/</span> <span class="n">numCourses</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, I’m fetching all my Course entities that are stored in Core Data
and introducing some logic that I will show later in my view. How are we going
to test that computed variable? You might make an ad hoc function that you can
test later, but that is not a clean way to do it. Plus, you don’t want data
logic in any view.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-clean-alternative">A Clean Alternative</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I tend to have a single <code>ViewModel</code> per <code>View</code> so that I
can test each component individually and use just what I need in each one of
them instead of having a big giant <code>ViewModel</code> to pass around in views.</p>
</div>
<div class="paragraph">
<p>With SwiftUI 2.0, you will find out that the initial project passes a
<code>managedObjectContext</code> as an <code>environmentObject</code> property. We do not want that.
It is not clean to take that context every time in each View that needs to fetch
data from the database, and I don’t want my views to know about that either.</p>
</div>
<div class="paragraph">
<p>What I came up with is a more MVVM way of doing this that involves our
easy-to-use publishers and subscribers.</p>
</div>
<div class="paragraph">
<p>Basically, you are going to create a singleton instance that watches over a
single entity in the database (in this case, the <code>Course</code> entity) and sends all
the courses to each subscriber that subscribes to it. This way, you can easily
instantiate multiple <strong>ViewModels</strong> that subscribe to the storage publisher and
operate some logic on those entities in a more dedicated and testable space.
Let’s see an example of what <code>CourseStorage</code> would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">class</span> <span class="kt">CourseStorage</span><span class="p">:</span> <span class="kt">NSObject</span><span class="p">,</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">courses</span> <span class="o">=</span> <span class="kt">CurrentValueSubject</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">Course</span><span class="p">],</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">([])</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">courseFetchController</span><span class="p">:</span> <span class="kt">NSFetchedResultsController</span><span class="o">&lt;</span><span class="kt">Course</span><span class="o">&gt;</span>

    <span class="kd">private</span> <span class="k">override</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">courseFetchController</span> <span class="o">=</span> <span class="kt">NSFetchedResultsController</span><span class="p">(</span>
            <span class="nv">fetchRequest</span><span class="p">:</span> <span class="kt">Course</span><span class="o">.</span><span class="kt">Request</span><span class="o">.</span><span class="n">all</span><span class="o">.</span><span class="n">rawValue</span><span class="p">,</span>
                <span class="nv">managedObjectContext</span><span class="p">:</span> <span class="kt">PersistenceController</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">container</span><span class="o">.</span><span class="n">viewContext</span><span class="p">,</span>
                <span class="nv">sectionNameKeyPath</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">cacheName</span><span class="p">:</span> <span class="kc">nil</span>
        <span class="p">)</span>

        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>

        <span class="n">courseFetchController</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="k">self</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="k">try</span> <span class="n">courseFetchController</span><span class="o">.</span><span class="nf">performFetch</span><span class="p">()</span>
            <span class="n">courses</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">courseFetchController</span><span class="o">.</span><span class="n">fetchedObjects</span> <span class="p">??</span> <span class="p">[]</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
            <span class="kt">NSLog</span><span class="p">(</span><span class="s">"Error: could not fetch objects"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">add</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">update</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">delete</span><span class="p">(</span><span class="nv">id</span><span class="p">:</span> <span class="kt">UUID</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">CourseStorage</span><span class="p">:</span> <span class="kt">NSFetchedResultsControllerDelegate</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">func</span> <span class="nf">controllerDidChangeContent</span><span class="p">(</span><span class="n">_</span> <span class="nv">controller</span><span class="p">:</span> <span class="kt">NSFetchedResultsController</span><span class="o">&lt;</span><span class="kt">NSFetchRequestResult</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">courses</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">fetchedObjects</span> <span class="k">as?</span> <span class="p">[</span><span class="kt">Course</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="n">logger</span><span class="o">.</span><span class="nf">log</span><span class="p">(</span><span class="s">"Context has changed, reloading courses"</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">courses</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">courses</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the code, I am creating a singleton <code>ObservableObject</code> that
exposes a course publisher. It is going to emit a new value when the
<code>managedObjectContext</code> entities change. You might have also noticed that I
placed the <code>PersistenceController</code> in the class itself. This way, we can forget
about passing it around to views, as I’ve explained before. In this class, I am
also handling everything that concerns the Core Data operations, such as saving,
adding, and deleting entities from the store. As such, I am separating database
logic from the app’s business logic.</p>
</div>
<div class="paragraph">
<p>Here is an example of how the <code>ViewModel</code> can be structured with these changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">class</span> <span class="kt">CourseViewViewModel</span><span class="p">:</span> <span class="kt">ObservableObject</span> <span class="p">{</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">activeCourses</span><span class="p">:</span> <span class="p">[</span><span class="kt">Course</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">overallGpa</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kd">@Published</span> <span class="k">var</span> <span class="nv">courses</span><span class="p">:</span> <span class="p">[</span><span class="kt">Course</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">{</span>
        <span class="k">willSet</span> <span class="p">{</span>
            <span class="n">activeCourses</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">mark</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>
            <span class="k">let</span> <span class="nv">scoreSum</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">score</span> <span class="p">}</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">}</span>
            <span class="k">let</span> <span class="nv">passedCourses</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">mark</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">}</span>
            <span class="n">overallGpa</span> <span class="o">=</span> <span class="n">scoreSum</span> <span class="o">/</span> <span class="n">passedCourses</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="k">var</span> <span class="nv">cancellable</span><span class="p">:</span> <span class="kt">AnyCancellable</span><span class="p">?</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">coursePublisher</span><span class="p">:</span> <span class="kt">AnyPublisher</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">Course</span><span class="p">],</span> <span class="kt">Never</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">CourseStorage</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="n">courses</span><span class="o">.</span><span class="nf">eraseToAnyPublisher</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">cancellable</span> <span class="o">=</span> <span class="n">coursePublisher</span><span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="p">[</span><span class="k">unowned</span> <span class="k">self</span><span class="p">]</span> <span class="n">courses</span> <span class="k">in</span>
            <span class="k">self</span><span class="o">.</span><span class="n">courses</span> <span class="o">=</span> <span class="n">courses</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ViewModel</code> now encapsulates all the data and logic that it is supposed to
handle. The code is pretty much self-explanatory: The <code>CourseViewModel</code>
subscribes to the CourseStorage publisher and receives up-to-date course values
from it.</p>
</div>
<div class="paragraph">
<p>You might be wondering why I am initialising the <code>ViewModel</code> with an
<code>AnyPublisher</code> value. Remember the testing advantage? It is precisely for this
situation. If I now want to test <code>CourseViewModel</code> and its logic, I can just
create a sample test array that contains a bunch of courses, pass that as an
array publisher to the <code>ViewModel</code>, and make all the asserts necessary for the
test.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">class</span> <span class="kt">TestVM</span><span class="p">:</span> <span class="kt">XCTest</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">simpleTest</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">courses</span> <span class="o">=</span> <span class="p">[[</span><span class="kt">Course</span><span class="p">(),</span> <span class="kt">Course</span><span class="p">(),</span> <span class="o">...</span><span class="p">]]</span><span class="o">.</span><span class="n">publisher</span>
        <span class="k">let</span> <span class="nv">vm</span> <span class="o">=</span> <span class="kt">CourseViewModel</span><span class="p">(</span><span class="nv">coursePublisher</span><span class="p">:</span> <span class="n">courses</span><span class="p">)</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="final-result">Final Result</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now, I am going to show you how simple and clean the View struct
looks with these changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">struct</span> <span class="kt">SimpleList</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@StateObject</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">viewModel</span> <span class="o">=</span> <span class="kt">CourseViewModel</span><span class="p">()</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kd">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>No more <code>managedObjectContext</code> passed around views. There is logic separation.
It is MVVM-compliant, easily testable, and <em>clean</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I have to say that I am pretty satisfied with the results. My
components are now all structured this way and I have not found a single issue
with the implementation. This is why I encourage you to try this out so that you
can organise big projects (and smaller ones) in a well-structured, maintainable,
and more elegant way.</p>
</div>
</div>
</div>
</article>
<script>
    function renderCodeTags() {
        const collection = document.getElementsByClassName("rouge highlight");

        for (let i = 0; i < collection.length; i++) {
        let cNode = collection[i].firstChild;
        let lang = cNode.getAttribute("data-lang");
        
        let newNode = document.createElement("div");
        newNode.className = "lang-tag";
        newNode.innerHTML += lang;
        
        collection[i].insertBefore(newNode, cNode);
        }
    }

    renderCodeTags()
</script>
    </main>

    <footer class="site-footer">
        <p>
            <a href=" /feed.xml">
                <i class="fa fa-rss"></i> rss
            </a>

            <a href="https://github.com/mattrighetti">
                <i class="fa fa-github"></i> mattrighetti
            </a>
        </p>
    </footer>

</body>

</html>