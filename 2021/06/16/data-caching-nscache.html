<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Data Caching with NSCache</title>
    <meta name="description"
        content="">
    <link rel="canonical" href="https://mattrighetti.github.io/2021/06/16/data-caching-nscache.html">
    <link rel="alternate" type="application/rss+xml" title="mattrighetti"
        href="https://mattrighetti.github.io/feed.xml">

    <link rel="stylesheet" href=" /css/font.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" href=" /css/style.css">
    <link rel="stylesheet" href=" /css/code.css">
</head>

<body class="mx-auto max-width">
    <header class="mx-auto site-header">
        <nav>
            <a class="-title" href="/">mattrighetti</a>
            
            
            
            
            
            
            
            <a href="/about.html">About</a>
            
            
            
            
            
            
            
            
            
            <a href="/projects.html">Projects</a>
            
            
            
            
            
            <a href="/resume.html">Resume</a>
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        </nav>
    </header>

    <main>
        <article>
  <h1>Data Caching with NSCache</h1>
  <div class="post-meta sect1">Jun 16, 2021</div>
  <div id="preamble">
<div class="sectionbody">
<div class="imageblock text-center">
<div class="content">
<img src="https://miro.medium.com/max/1400/1*zVw56-JToWySViotHWqtMA.png" alt="1*zVw56 JToWySViotHWqtMA">
</div>
</div>
<div class="paragraph">
<p>I recently open-sourced my
<a href="https://github.com/mattrighetti/HNReaderApp">HackerNews reader for macOS</a> that
is entirely written in SwiftUI for macOS. Analysing my scenario can help to
explain data caching and data waste avoidance. If you want to get a more
detailed idea of the code, you can follow along in the project’s GitHub
repository.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scenario">Scenario</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hacker News is a well-known website that stores news reported by users on the
platform. Each individual story is going to be represented by an Item struct, as
the HN API’s documentation specifies. We want to fetch available items for the
user to read in the most data-efficient way.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initial-implementation-with-no-cache-usage">Initial Implementation With No Cache Usage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The application has an ItemCell view that takes an ItemId from the parent view,
and as soon as it appears on screen, it will automatically fetch the item and
display it for me. This approach makes the data usage very low and removes a lot
of pressure on the backend because only displayed items will actually be
fetched.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="https://miro.medium.com/max/1400/1*-0KWAWmDnu2p_MdFVzfDuA.png" alt="1* 0KWAWmDnu2p MdFVzfDuA">
</div>
</div>
<div class="paragraph">
<p>The application’s sidebar lets the user navigate between the five different
categories of stories. As you can imagine, some news can potentially belong to
multiple categories, so when the user switches back and forth between
categories, they are basically asking for the same items that have previously
been fetched.</p>
</div>
<div class="paragraph">
<p>This kind of approach without some background logic can drastically increase
your data usage, decrease the overall app performance, and also put a lot of
pressure on the HackerNews backend that will unnecessarily give us the same
information multiple times.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="caching-data">Caching Data</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What we could actually do to solve the problem is cache downloaded items by
their IDs. This way, items will be fetched just once and the application won’t
waste data with useless repeated requests to the backend.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="https://miro.medium.com/max/1400/1*dGewxEQNZvEdXv1q986s6A.png" alt="1*dGewxEQNZvEdXv1q986s6A">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementation">Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We know that each item is uniquely identified by an <code>ItemId</code>, which is an
integer variable. Therefore, we could use that datum to store and retrieve the
item from the cache.</p>
</div>
<div class="paragraph">
<p>At the time of writing, the
<a href="https://developer.apple.com/documentation/foundation/nscache"><code>NSCache</code></a>
implementation only accepts class types, so we need to create a simple class
wrapper for the Item struct if we want to store it in the cache object. In this
scenario, we don’t need to wrap our key (<code>ItemId</code>) because there is a shorter
way to do that: casting it to a <code>String</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">class</span> <span class="kt">StructWrapper</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">NSObject</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">_struct</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">_struct</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Storing and retrieving objects is pretty straightforward now. We need a cache
object with two functions: one to cache the object and the other to get objects
back if they are found. I did also implement the common singleton design pattern
to make sure that I am always using the same cache object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">class</span> <span class="kt">ItemCache</span><span class="p">:</span> <span class="kt">NSCache</span><span class="o">&lt;</span><span class="kt">NSString</span><span class="p">,</span> <span class="kt">StructWrapper</span><span class="o">&lt;</span><span class="kt">Item</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">shared</span> <span class="o">=</span> <span class="kt">ItemCache</span><span class="p">()</span>

    <span class="kd">func</span> <span class="nf">cache</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">Item</span><span class="p">,</span> <span class="k">for</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">keyString</span> <span class="o">=</span> <span class="kt">NSString</span><span class="p">(</span><span class="nv">format</span><span class="p">:</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">itemWrapper</span> <span class="o">=</span> <span class="kt">StructWrapper</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">setObject</span><span class="p">(</span><span class="n">itemWrapper</span><span class="p">,</span> <span class="nv">forKey</span><span class="p">:</span> <span class="n">keyString</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">getItem</span><span class="p">(</span><span class="k">for</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Item</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">keyString</span> <span class="o">=</span> <span class="kt">NSString</span><span class="p">(</span><span class="nv">format</span><span class="p">:</span> <span class="s">"%d"</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">itemWrapper</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="nf">object</span><span class="p">(</span><span class="nv">forKey</span><span class="p">:</span> <span class="n">keyString</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">itemWrapper</span><span class="p">?</span><span class="o">.</span><span class="n">value</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have everything that we need to cache elements and check if one exists in
memory before fetching it. The fetching function will check for a cache hit/miss
before actually fetching the data. The fetching will only happen if we get a
cache miss for the requested object, and when the item is correctly fetched, we
only have to save it in the cache. The next time we try to fetch that item, it
will be immediately taken from the cache without any additional fetch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="swift"><span class="kd">private</span> <span class="kd">func</span> <span class="nf">fetchItem</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">cacheKey</span> <span class="o">=</span> <span class="n">itemId</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">cachedItem</span> <span class="o">=</span> <span class="kt">ItemCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">getItem</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">cacheKey</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">cachedItem</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">itemDownloader</span><span class="o">.</span><span class="nf">downloadItem</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">item</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">item</span> <span class="o">=</span> <span class="n">item</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="kt">ItemCache</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">cache</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nv">for</span><span class="p">:</span> <span class="n">cacheKey</span><span class="p">)</span>
            <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="k">async</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Optimisation is something that you must always be looking for — both for your
users and other third-party services that you might use in your application.
With a very simple object, we have actually made some pretty big improvements.
Now a fetched item will be cached and ready to be retrieved with a cost of
<strong><em>O(1)</em></strong> the next time you need it.</p>
</div>
</div>
</div>
</article>
<script>
    function renderCodeTags() {
        const collection = document.getElementsByClassName("rouge highlight");

        for (let i = 0; i < collection.length; i++) {
        let cNode = collection[i].firstChild;
        let lang = cNode.getAttribute("data-lang");
        
        let newNode = document.createElement("div");
        newNode.className = "lang-tag";
        newNode.innerHTML += lang;
        
        collection[i].insertBefore(newNode, cNode);
        }
    }

    renderCodeTags()
</script>
    </main>

    <footer class="site-footer">
        <p>
            <a href=" /feed.xml">
                <i class="fa fa-rss"></i> rss
            </a>

            <a href="https://github.com/mattrighetti">
                <i class="fa fa-github"></i> mattrighetti
            </a>
        </p>
    </footer>

</body>

</html>